### § 1.1 C语言的起源

c语言的产生竟然源于一个失败的项目。

1969年，通用电气、麻绳理工学院和贝尔实验室联合创立了一个庞大的项目---Multics工程。该项目的目的是创建一个操作系统，但显然遇到了麻烦：它不但无法交付原先所承诺的快速而便捷的在线系统，甚至连一点有用的东西都没有弄出来。虽然开发小组勉强让Multics开动起来，但他们还是陷入了泥淖，就像IBM在OS/360上面一样。他们试图建立一个非常巨大的操作系统，能够应用于规模很小的硬件系统中。Multics成了总结工程教训的宝库，但它同时也成为C语言体现“小既是美”铺平了道路。

#### 插入标题测试

当心灰意冷的贝尔实验室的专家撤离Multics工程后，他们又去寻找其他任务。其中一个名叫Ken Thompson的研究人员对另一个操作系统很感兴趣，他为此好几次向贝尔管理层提议，但均遭否决。在等待官方批准时，Thompson和他的同事Dennis Ritchie自娱自乐，把Thompson的“太空旅行”软件移植到不太常用的PDP-7系统上。太空旅行软件模拟太阳系主要星体，把它们显示在图形屏幕上，并创建了一架航天飞机，它能够飞行并降落到各个行星上。与此同时，Thompson加紧工作，为PDP-7编写了一个简易的新型操作系统。它比Multics简单很多，也轻便很多。整个系统都是用汇编语言编写的。Brian Kernighan在1970年给它取名为Unix。

是先用c语言还是先有Unix呢？说起这个问题，人们很容易陷入先有鸡还是先要蛋的套套中。确切地说，Unix比c语言出现的早，这也是为什么Unix的系统时间是从1970年1月1日起按秒计算的。用汇编语言编写Unix显得很笨拙，在编制数据结构时浪费了大量的时间，而且系统难以调试，理解起来也很困难。在用Fortran进行了一番简短而又不成功的尝试后，Thompson创建了B语言。但是，B语言从来不曾真正成功过，因为硬件系统内存限制，它只允许放置解释器，而不是编译器，由此产生的低效阻碍了使用B语言进行Unix自身的系统编程。

当1970年开发平台转移到PDP-11以后，无类型语言很快就显得不合时宜了。这种处理器以硬件支持几种不同长度的数据类型为特色，而B语言无法表达不同的数据类型。效率也是一个问题，这也迫使Thompson在PDP-11上重新用汇编语言实现了Unix。Dennis Ritchie利用PDP-11的强大功能，创立了能够同时解决多种数据类型和效率的“New B”（这个名字很快变成了“C”）语言，它采用了编译模式而不是解释模式，并引入了类型系统。每个变量在使用前必须声明。

c语言的早期体验

c语言排斥强类型，它允许程序员需要时可以在不同类型的对象间赋值。类型系统的加入可以说是事后诸葛，从未在可能性方面进行过认真的评估和严格的测试。时至今日，许多C程序员仍然认为“强类型”只不过是增加了敲击键盘的无用功。

除了类型系统之外，c语言的许多其它特性是为了方便编译器设计者而建立的（为什么不呢？开始几年c语言的主要客户就是那些编译器的设计者）。根据编译器设计者的思路而发展形成的语言特性有：

- 数组下标从0而不是1开始。

- c语言的基本数据类型直接与底层硬件相对应。

- auto关键字显然是摆设。

- 表达式中的数组名可以看作是指针。

- float被自动扩展为double。

- 不允许嵌套函数（函数内部包含另一个函数的定义）

- register关键字

为了c编译器设计者的方便而建立的其它语言特性还有很多。这本身不是一件坏事，它大大简化了c语言本身，而且通过回避一些复杂的语言要素，c语言更容易学习和实现，而且效率非常高。

和其它大多数语言不同，c语言有一个漫长的进化过程。在目前这个形式之前，它经历了许多中间状态。它历经多年，从一个实用工具进化为一种经过大量实验和测试的语言。第一个c语言编译器大约出现在1970年。时光荏苒，作为它的根基的Unix系统得到了广泛使用，c语言也随之茁壮成长。它对直接由硬件支持的底层操作的强调，带来了极高的效率和移植性，反过来也帮助了Unix获得了巨大的成功。

测试内容，待更新。。。



### 参考文献：

1. https://zhuanlan.zhihu.com/p/65728480

